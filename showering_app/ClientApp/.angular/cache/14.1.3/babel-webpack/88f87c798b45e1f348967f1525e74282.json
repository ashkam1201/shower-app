{"ast":null,"code":"import _asyncToGenerator from \"/Users/owtgvaolt210/RiderProjects/showering_app/showering_app/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { Deferred, ErrorFactory, isIndexedDBAvailable, uuidv4, getGlobal, base64, issuedAtTime, calculateBackoffMillis, getModularInstance } from '@firebase/util';\nimport { Logger } from '@firebase/logger';\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst APP_CHECK_STATES = new Map();\nconst DEFAULT_STATE = {\n  activated: false,\n  tokenObservers: []\n};\nconst DEBUG_STATE = {\n  initialized: false,\n  enabled: false\n};\n/**\r\n * Gets a reference to the state object.\r\n */\n\nfunction getStateReference(app) {\n  return APP_CHECK_STATES.get(app) || Object.assign({}, DEFAULT_STATE);\n}\n/**\r\n * Set once on initialization. The map should hold the same reference to the\r\n * same object until this entry is deleted.\r\n */\n\n\nfunction setInitialState(app, state) {\n  APP_CHECK_STATES.set(app, state);\n  return APP_CHECK_STATES.get(app);\n}\n\nfunction getDebugState() {\n  return DEBUG_STATE;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1';\nconst EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaV3Token';\nconst EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = 'exchangeRecaptchaEnterpriseToken';\nconst EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\nconst TOKEN_REFRESH_TIME = {\n  /**\r\n   * The offset time before token natural expiration to run the refresh.\r\n   * This is currently 5 minutes.\r\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n\n  /**\r\n   * This is the first retrial wait after an error. This is currently\r\n   * 30 seconds.\r\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n\n  /**\r\n   * This is the maximum retrial wait, currently 16 minutes.\r\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n/**\r\n * One day in millis, for certain error code backoffs.\r\n */\n\nconst ONE_DAY = 24 * 60 * 60 * 1000;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Port from auth proactiverefresh.js\r\n *\r\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\n\nclass Refresher {\n  constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\n    this.operation = operation;\n    this.retryPolicy = retryPolicy;\n    this.getWaitDuration = getWaitDuration;\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n    this.pending = null;\n    this.nextErrorWaitInterval = lowerBound;\n\n    if (lowerBound > upperBound) {\n      throw new Error('Proactive refresh lower bound greater than upper bound!');\n    }\n  }\n\n  start() {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(() => {\n      /* we don't care about the result */\n    });\n  }\n\n  stop() {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  }\n\n  isRunning() {\n    return !!this.pending;\n  }\n\n  process(hasSucceeded) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.stop();\n\n      try {\n        _this.pending = new Deferred();\n        yield sleep(_this.getNextRun(hasSucceeded)); // Why do we resolve a promise, then immediate wait for it?\n        // We do it to make the promise chain cancellable.\n        // We can call stop() which rejects the promise before the following line execute, which makes\n        // the code jump to the catch block.\n        // TODO: unit test this\n\n        _this.pending.resolve();\n\n        yield _this.pending.promise;\n        _this.pending = new Deferred();\n        yield _this.operation();\n\n        _this.pending.resolve();\n\n        yield _this.pending.promise;\n\n        _this.process(true).catch(() => {\n          /* we don't care about the result */\n        });\n      } catch (error) {\n        if (_this.retryPolicy(error)) {\n          _this.process(false).catch(() => {\n            /* we don't care about the result */\n          });\n        } else {\n          _this.stop();\n        }\n      }\n    })();\n  }\n\n  getNextRun(hasSucceeded) {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound; // Return typical wait duration interval after a successful operation.\n\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      const currentErrorWaitInterval = this.nextErrorWaitInterval; // Double interval for next consecutive error.\n\n      this.nextErrorWaitInterval *= 2; // Make sure next wait interval does not exceed the maximum upper bound.\n\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n\n      return currentErrorWaitInterval;\n    }\n  }\n\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst ERRORS = {\n  [\"already-initialized\"\n  /* AppCheckError.ALREADY_INITIALIZED */\n  ]: 'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' + 'different options. To avoid this error, call initializeAppCheck() with the ' + 'same options as when it was originally called. This will return the ' + 'already initialized instance.',\n  [\"use-before-activation\"\n  /* AppCheckError.USE_BEFORE_ACTIVATION */\n  ]: 'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' + 'Call initializeAppCheck() before instantiating other Firebase services.',\n  [\"fetch-network-error\"\n  /* AppCheckError.FETCH_NETWORK_ERROR */\n  ]: 'Fetch failed to connect to a network. Check Internet connection. ' + 'Original error: {$originalErrorMessage}.',\n  [\"fetch-parse-error\"\n  /* AppCheckError.FETCH_PARSE_ERROR */\n  ]: 'Fetch client could not parse response.' + ' Original error: {$originalErrorMessage}.',\n  [\"fetch-status-error\"\n  /* AppCheckError.FETCH_STATUS_ERROR */\n  ]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n  [\"storage-open\"\n  /* AppCheckError.STORAGE_OPEN */\n  ]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n  [\"storage-get\"\n  /* AppCheckError.STORAGE_GET */\n  ]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n  [\"storage-set\"\n  /* AppCheckError.STORAGE_WRITE */\n  ]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n  [\"recaptcha-error\"\n  /* AppCheckError.RECAPTCHA_ERROR */\n  ]: 'ReCAPTCHA error.',\n  [\"throttled\"\n  /* AppCheckError.THROTTLED */\n  ]: `Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}`\n};\nconst ERROR_FACTORY = new ErrorFactory('appCheck', 'AppCheck', ERRORS);\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nfunction getRecaptcha(isEnterprise = false) {\n  var _a;\n\n  if (isEnterprise) {\n    return (_a = self.grecaptcha) === null || _a === void 0 ? void 0 : _a.enterprise;\n  }\n\n  return self.grecaptcha;\n}\n\nfunction ensureActivated(app) {\n  if (!getStateReference(app).activated) {\n    throw ERROR_FACTORY.create(\"use-before-activation\"\n    /* AppCheckError.USE_BEFORE_ACTIVATION */\n    , {\n      appName: app.name\n    });\n  }\n}\n\nfunction getDurationString(durationInMillis) {\n  const totalSeconds = Math.round(durationInMillis / 1000);\n  const days = Math.floor(totalSeconds / (3600 * 24));\n  const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);\n  const minutes = Math.floor((totalSeconds - days * 3600 * 24 - hours * 3600) / 60);\n  const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;\n  let result = '';\n\n  if (days) {\n    result += pad(days) + 'd:';\n  }\n\n  if (hours) {\n    result += pad(hours) + 'h:';\n  }\n\n  result += pad(minutes) + 'm:' + pad(seconds) + 's';\n  return result;\n}\n\nfunction pad(value) {\n  if (value === 0) {\n    return '00';\n  }\n\n  return value >= 10 ? value.toString() : '0' + value;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction exchangeToken(_x, _x2) {\n  return _exchangeToken.apply(this, arguments);\n}\n\nfunction _exchangeToken() {\n  _exchangeToken = _asyncToGenerator(function* ({\n    url,\n    body\n  }, heartbeatServiceProvider) {\n    const headers = {\n      'Content-Type': 'application/json'\n    }; // If heartbeat service exists, add heartbeat header string to the header.\n\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n      optional: true\n    });\n\n    if (heartbeatService) {\n      const heartbeatsHeader = yield heartbeatService.getHeartbeatsHeader();\n\n      if (heartbeatsHeader) {\n        headers['X-Firebase-Client'] = heartbeatsHeader;\n      }\n    }\n\n    const options = {\n      method: 'POST',\n      body: JSON.stringify(body),\n      headers\n    };\n    let response;\n\n    try {\n      response = yield fetch(url, options);\n    } catch (originalError) {\n      throw ERROR_FACTORY.create(\"fetch-network-error\"\n      /* AppCheckError.FETCH_NETWORK_ERROR */\n      , {\n        originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n      });\n    }\n\n    if (response.status !== 200) {\n      throw ERROR_FACTORY.create(\"fetch-status-error\"\n      /* AppCheckError.FETCH_STATUS_ERROR */\n      , {\n        httpStatus: response.status\n      });\n    }\n\n    let responseBody;\n\n    try {\n      // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n      responseBody = yield response.json();\n    } catch (originalError) {\n      throw ERROR_FACTORY.create(\"fetch-parse-error\"\n      /* AppCheckError.FETCH_PARSE_ERROR */\n      , {\n        originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n      });\n    } // Protobuf duration format.\n    // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n\n\n    const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n\n    if (!match || !match[2] || isNaN(Number(match[1]))) {\n      throw ERROR_FACTORY.create(\"fetch-parse-error\"\n      /* AppCheckError.FETCH_PARSE_ERROR */\n      , {\n        originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration ` + `format: ${responseBody.ttl}`\n      });\n    }\n\n    const timeToLiveAsNumber = Number(match[1]) * 1000;\n    const now = Date.now();\n    return {\n      token: responseBody.token,\n      expireTimeMillis: now + timeToLiveAsNumber,\n      issuedAtTimeMillis: now\n    };\n  });\n  return _exchangeToken.apply(this, arguments);\n}\n\nfunction getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_v3_token': reCAPTCHAToken\n    }\n  };\n}\n\nfunction getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_enterprise_token': reCAPTCHAToken\n    }\n  };\n}\n\nfunction getExchangeDebugTokenRequest(app, debugToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\nlet dbPromise = null;\n\nfunction getDBPromise() {\n  if (dbPromise) {\n    return dbPromise;\n  }\n\n  dbPromise = new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onsuccess = event => {\n        resolve(event.target.result);\n      };\n\n      request.onerror = event => {\n        var _a;\n\n        reject(ERROR_FACTORY.create(\"storage-open\"\n        /* AppCheckError.STORAGE_OPEN */\n        , {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n\n      request.onupgradeneeded = event => {\n        const db = event.target.result; // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(ERROR_FACTORY.create(\"storage-open\"\n      /* AppCheckError.STORAGE_OPEN */\n      , {\n        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n      }));\n    }\n  });\n  return dbPromise;\n}\n\nfunction readTokenFromIndexedDB(app) {\n  return read(computeKey(app));\n}\n\nfunction writeTokenToIndexedDB(app, token) {\n  return write(computeKey(app), token);\n}\n\nfunction writeDebugTokenToIndexedDB(token) {\n  return write(DEBUG_TOKEN_KEY, token);\n}\n\nfunction readDebugTokenFromIndexedDB() {\n  return read(DEBUG_TOKEN_KEY);\n}\n\nfunction write(_x3, _x4) {\n  return _write.apply(this, arguments);\n}\n\nfunction _write() {\n  _write = _asyncToGenerator(function* (key, value) {\n    const db = yield getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.put({\n      compositeKey: key,\n      value\n    });\n    return new Promise((resolve, reject) => {\n      request.onsuccess = _event => {\n        resolve();\n      };\n\n      transaction.onerror = event => {\n        var _a;\n\n        reject(ERROR_FACTORY.create(\"storage-set\"\n        /* AppCheckError.STORAGE_WRITE */\n        , {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n    });\n  });\n  return _write.apply(this, arguments);\n}\n\nfunction read(_x5) {\n  return _read.apply(this, arguments);\n}\n\nfunction _read() {\n  _read = _asyncToGenerator(function* (key) {\n    const db = yield getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.get(key);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = event => {\n        const result = event.target.result;\n\n        if (result) {\n          resolve(result.value);\n        } else {\n          resolve(undefined);\n        }\n      };\n\n      transaction.onerror = event => {\n        var _a;\n\n        reject(ERROR_FACTORY.create(\"storage-get\"\n        /* AppCheckError.STORAGE_GET */\n        , {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n    });\n  });\n  return _read.apply(this, arguments);\n}\n\nfunction computeKey(app) {\n  return `${app.options.appId}-${app.name}`;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst logger = new Logger('@firebase/app-check');\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\r\n */\n\nfunction readTokenFromStorage(_x6) {\n  return _readTokenFromStorage.apply(this, arguments);\n}\n/**\r\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\r\n */\n\n\nfunction _readTokenFromStorage() {\n  _readTokenFromStorage = _asyncToGenerator(function* (app) {\n    if (isIndexedDBAvailable()) {\n      let token = undefined;\n\n      try {\n        token = yield readTokenFromIndexedDB(app);\n      } catch (e) {\n        // swallow the error and return undefined\n        logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\n      }\n\n      return token;\n    }\n\n    return undefined;\n  });\n  return _readTokenFromStorage.apply(this, arguments);\n}\n\nfunction writeTokenToStorage(app, token) {\n  if (isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(e => {\n      // swallow the error and resolve the promise\n      logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\n    });\n  }\n\n  return Promise.resolve();\n}\n\nfunction readOrCreateDebugTokenFromStorage() {\n  return _readOrCreateDebugTokenFromStorage.apply(this, arguments);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction _readOrCreateDebugTokenFromStorage() {\n  _readOrCreateDebugTokenFromStorage = _asyncToGenerator(function* () {\n    /**\r\n     * Theoretically race condition can happen if we read, then write in 2 separate transactions.\r\n     * But it won't happen here, because this function will be called exactly once.\r\n     */\n    let existingDebugToken = undefined;\n\n    try {\n      existingDebugToken = yield readDebugTokenFromIndexedDB();\n    } catch (_e) {// failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n    }\n\n    if (!existingDebugToken) {\n      // create a new debug token\n      const newToken = uuidv4(); // We don't need to block on writing to indexeddb\n      // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\n      // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n      // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n      // You should switch to a different browser that supports indexeddb\n\n      writeDebugTokenToIndexedDB(newToken).catch(e => logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));\n      return newToken;\n    } else {\n      return existingDebugToken;\n    }\n  });\n  return _readOrCreateDebugTokenFromStorage.apply(this, arguments);\n}\n\nfunction isDebugMode() {\n  const debugState = getDebugState();\n  return debugState.enabled;\n}\n\nfunction getDebugToken() {\n  return _getDebugToken.apply(this, arguments);\n}\n\nfunction _getDebugToken() {\n  _getDebugToken = _asyncToGenerator(function* () {\n    const state = getDebugState();\n\n    if (state.enabled && state.token) {\n      return state.token.promise;\n    } else {\n      // should not happen!\n      throw Error(`\n            Can't get debug token in production mode.\n        `);\n    }\n  });\n  return _getDebugToken.apply(this, arguments);\n}\n\nfunction initializeDebugMode() {\n  const globals = getGlobal();\n  const debugState = getDebugState(); // Set to true if this function has been called, whether or not\n  // it enabled debug mode.\n\n  debugState.initialized = true;\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\n    return;\n  }\n\n  debugState.enabled = true;\n  const deferredToken = new Deferred();\n  debugState.token = deferredToken;\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\n\n\nconst defaultTokenErrorData = {\n  error: 'UNKNOWN_ERROR'\n};\n/**\r\n * Stringify and base64 encode token error data.\r\n *\r\n * @param tokenError Error data, currently hardcoded.\r\n */\n\nfunction formatDummyToken(tokenErrorData) {\n  return base64.encodeString(JSON.stringify(tokenErrorData),\n  /* webSafe= */\n  false);\n}\n/**\r\n * This function always resolves.\r\n * The result will contain an error field if there is any error.\r\n * In case there is an error, the token field in the result will be populated with a dummy value\r\n */\n\n\nfunction getToken$2(_x7) {\n  return _getToken$.apply(this, arguments);\n}\n/**\r\n * Internal API for limited use tokens. Skips all FAC state and simply calls\r\n * the underlying provider.\r\n */\n\n\nfunction _getToken$() {\n  _getToken$ = _asyncToGenerator(function* (appCheck, forceRefresh = false) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const state = getStateReference(app);\n    /**\r\n     * First check if there is a token in memory from a previous `getToken()` call.\r\n     */\n\n    let token = state.token;\n    let error = undefined;\n    /**\r\n     * If an invalid token was found in memory, clear token from\r\n     * memory and unset the local variable `token`.\r\n     */\n\n    if (token && !isValid(token)) {\n      state.token = undefined;\n      token = undefined;\n    }\n    /**\r\n     * If there is no valid token in memory, try to load token from indexedDB.\r\n     */\n\n\n    if (!token) {\n      // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\n      const cachedToken = yield state.cachedTokenPromise;\n\n      if (cachedToken) {\n        if (isValid(cachedToken)) {\n          token = cachedToken;\n        } else {\n          // If there was an invalid token in the indexedDB cache, clear it.\n          yield writeTokenToStorage(app, undefined);\n        }\n      }\n    } // Return the cached token (from either memory or indexedDB) if it's valid\n\n\n    if (!forceRefresh && token && isValid(token)) {\n      return {\n        token: token.token\n      };\n    } // Only set to true if this `getToken()` call is making the actual\n    // REST call to the exchange endpoint, versus waiting for an already\n    // in-flight call (see debug and regular exchange endpoint paths below)\n\n\n    let shouldCallListeners = false;\n    /**\r\n     * DEBUG MODE\r\n     * If debug mode is set, and there is no cached token, fetch a new App\r\n     * Check token using the debug token, and return it directly.\r\n     */\n\n    if (isDebugMode()) {\n      // Avoid making another call to the exchange endpoint if one is in flight.\n      if (!state.exchangeTokenPromise) {\n        state.exchangeTokenPromise = exchangeToken(getExchangeDebugTokenRequest(app, yield getDebugToken()), appCheck.heartbeatServiceProvider).finally(() => {\n          // Clear promise when settled - either resolved or rejected.\n          state.exchangeTokenPromise = undefined;\n        });\n        shouldCallListeners = true;\n      }\n\n      const tokenFromDebugExchange = yield state.exchangeTokenPromise; // Write debug token to indexedDB.\n\n      yield writeTokenToStorage(app, tokenFromDebugExchange); // Write debug token to state.\n\n      state.token = tokenFromDebugExchange;\n      return {\n        token: tokenFromDebugExchange.token\n      };\n    }\n    /**\r\n     * There are no valid tokens in memory or indexedDB and we are not in\r\n     * debug mode.\r\n     * Request a new token from the exchange endpoint.\r\n     */\n\n\n    try {\n      // Avoid making another call to the exchange endpoint if one is in flight.\n      if (!state.exchangeTokenPromise) {\n        // state.provider is populated in initializeAppCheck()\n        // ensureActivated() at the top of this function checks that\n        // initializeAppCheck() has been called.\n        state.exchangeTokenPromise = state.provider.getToken().finally(() => {\n          // Clear promise when settled - either resolved or rejected.\n          state.exchangeTokenPromise = undefined;\n        });\n        shouldCallListeners = true;\n      }\n\n      token = yield getStateReference(app).exchangeTokenPromise;\n    } catch (e) {\n      if (e.code === `appCheck/${\"throttled\"\n      /* AppCheckError.THROTTLED */\n      }`) {\n        // Warn if throttled, but do not treat it as an error.\n        logger.warn(e.message);\n      } else {\n        // `getToken()` should never throw, but logging error text to console will aid debugging.\n        logger.error(e);\n      } // Always save error to be added to dummy token.\n\n\n      error = e;\n    }\n\n    let interopTokenResult;\n\n    if (!token) {\n      // If token is undefined, there must be an error.\n      // Return a dummy token along with the error.\n      interopTokenResult = makeDummyTokenResult(error);\n    } else if (error) {\n      if (isValid(token)) {\n        // It's also possible a valid token exists, but there's also an error.\n        // (Such as if the token is almost expired, tries to refresh, and\n        // the exchange request fails.)\n        // We add a special error property here so that the refresher will\n        // count this as a failed attempt and use the backoff instead of\n        // retrying repeatedly with no delay, but any 3P listeners will not\n        // be hindered in getting the still-valid token.\n        interopTokenResult = {\n          token: token.token,\n          internalError: error\n        };\n      } else {\n        // No invalid tokens should make it to this step. Memory and cached tokens\n        // are checked. Other tokens are from fresh exchanges. But just in case.\n        interopTokenResult = makeDummyTokenResult(error);\n      }\n    } else {\n      interopTokenResult = {\n        token: token.token\n      }; // write the new token to the memory state as well as the persistent storage.\n      // Only do it if we got a valid new token\n\n      state.token = token;\n      yield writeTokenToStorage(app, token);\n    }\n\n    if (shouldCallListeners) {\n      notifyTokenListeners(app, interopTokenResult);\n    }\n\n    return interopTokenResult;\n  });\n  return _getToken$.apply(this, arguments);\n}\n\nfunction getLimitedUseToken$1(_x8) {\n  return _getLimitedUseToken$.apply(this, arguments);\n}\n\nfunction _getLimitedUseToken$() {\n  _getLimitedUseToken$ = _asyncToGenerator(function* (appCheck) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const {\n      provider\n    } = getStateReference(app);\n\n    if (isDebugMode()) {\n      const debugToken = yield getDebugToken();\n      const {\n        token\n      } = yield exchangeToken(getExchangeDebugTokenRequest(app, debugToken), appCheck.heartbeatServiceProvider);\n      return {\n        token\n      };\n    } else {\n      // provider is definitely valid since we ensure AppCheck was activated\n      const {\n        token\n      } = yield provider.getToken();\n      return {\n        token\n      };\n    }\n  });\n  return _getLimitedUseToken$.apply(this, arguments);\n}\n\nfunction addTokenListener(appCheck, type, listener, onError) {\n  const {\n    app\n  } = appCheck;\n  const state = getStateReference(app);\n  const tokenObserver = {\n    next: listener,\n    error: onError,\n    type\n  };\n  state.tokenObservers = [...state.tokenObservers, tokenObserver]; // Invoke the listener async immediately if there is a valid token\n  // in memory.\n\n  if (state.token && isValid(state.token)) {\n    const validToken = state.token;\n    Promise.resolve().then(() => {\n      listener({\n        token: validToken.token\n      });\n      initTokenRefresher(appCheck);\n    }).catch(() => {\n      /* we don't care about exceptions thrown in listeners */\n    });\n  }\n  /**\r\n   * Wait for any cached token promise to resolve before starting the token\r\n   * refresher. The refresher checks to see if there is an existing token\r\n   * in state and calls the exchange endpoint if not. We should first let the\r\n   * IndexedDB check have a chance to populate state if it can.\r\n   *\r\n   * Listener call isn't needed here because cachedTokenPromise will call any\r\n   * listeners that exist when it resolves.\r\n   */\n  // state.cachedTokenPromise is always populated in `activate()`.\n\n\n  void state.cachedTokenPromise.then(() => initTokenRefresher(appCheck));\n}\n\nfunction removeTokenListener(app, listener) {\n  const state = getStateReference(app);\n  const newObservers = state.tokenObservers.filter(tokenObserver => tokenObserver.next !== listener);\n\n  if (newObservers.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {\n    state.tokenRefresher.stop();\n  }\n\n  state.tokenObservers = newObservers;\n}\n/**\r\n * Logic to create and start refresher as needed.\r\n */\n\n\nfunction initTokenRefresher(appCheck) {\n  const {\n    app\n  } = appCheck;\n  const state = getStateReference(app); // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n  // is not true.\n\n  let refresher = state.tokenRefresher;\n\n  if (!refresher) {\n    refresher = createTokenRefresher(appCheck);\n    state.tokenRefresher = refresher;\n  }\n\n  if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {\n    refresher.start();\n  }\n}\n\nfunction createTokenRefresher(appCheck) {\n  const {\n    app\n  } = appCheck;\n  return new Refresher(\n  /*#__PURE__*/\n  // Keep in mind when this fails for any reason other than the ones\n  // for which we should retry, it will effectively stop the proactive refresh.\n  _asyncToGenerator(function* () {\n    const state = getStateReference(app); // If there is no token, we will try to load it from storage and use it\n    // If there is a token, we force refresh it because we know it's going to expire soon\n\n    let result;\n\n    if (!state.token) {\n      result = yield getToken$2(appCheck);\n    } else {\n      result = yield getToken$2(appCheck, true);\n    }\n    /**\r\n     * getToken() always resolves. In case the result has an error field defined, it means\r\n     * the operation failed, and we should retry.\r\n     */\n\n\n    if (result.error) {\n      throw result.error;\n    }\n    /**\r\n     * A special `internalError` field reflects that there was an error\r\n     * getting a new token from the exchange endpoint, but there's still a\r\n     * previous token that's valid for now and this should be passed to 2P/3P\r\n     * requests for a token. But we want this callback (`this.operation` in\r\n     * `Refresher`) to throw in order to kick off the Refresher's retry\r\n     * backoff. (Setting `hasSucceeded` to false.)\r\n     */\n\n\n    if (result.internalError) {\n      throw result.internalError;\n    }\n  }), () => {\n    return true;\n  }, () => {\n    const state = getStateReference(app);\n\n    if (state.token) {\n      // issuedAtTime + (50% * total TTL) + 5 minutes\n      let nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1000; // Do not allow refresh time to be past (expireTime - 5 minutes)\n\n      const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\n      nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\n      return Math.max(0, nextRefreshTimeMillis - Date.now());\n    } else {\n      return 0;\n    }\n  }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\n}\n\nfunction notifyTokenListeners(app, token) {\n  const observers = getStateReference(app).tokenObservers;\n\n  for (const observer of observers) {\n    try {\n      if (observer.type === \"EXTERNAL\"\n      /* ListenerType.EXTERNAL */\n      && token.error != null) {\n        // If this listener was added by a 3P call, send any token error to\n        // the supplied error handler. A 3P observer always has an error\n        // handler.\n        observer.error(token.error);\n      } else {\n        // If the token has no error field, always return the token.\n        // If this is a 2P listener, return the token, whether or not it\n        // has an error field.\n        observer.next(token);\n      }\n    } catch (e) {// Errors in the listener function itself are always ignored.\n    }\n  }\n}\n\nfunction isValid(token) {\n  return token.expireTimeMillis - Date.now() > 0;\n}\n\nfunction makeDummyTokenResult(error) {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error\n  };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * AppCheck Service class.\r\n */\n\n\nclass AppCheckService {\n  constructor(app, heartbeatServiceProvider) {\n    this.app = app;\n    this.heartbeatServiceProvider = heartbeatServiceProvider;\n  }\n\n  _delete() {\n    const {\n      tokenObservers\n    } = getStateReference(this.app);\n\n    for (const tokenObserver of tokenObservers) {\n      removeTokenListener(this.app, tokenObserver.next);\n    }\n\n    return Promise.resolve();\n  }\n\n}\n\nfunction factory(app, heartbeatServiceProvider) {\n  return new AppCheckService(app, heartbeatServiceProvider);\n}\n\nfunction internalFactory(appCheck) {\n  return {\n    getToken: forceRefresh => getToken$2(appCheck, forceRefresh),\n    getLimitedUseToken: () => getLimitedUseToken$1(appCheck),\n    addTokenListener: listener => addTokenListener(appCheck, \"INTERNAL\"\n    /* ListenerType.INTERNAL */\n    , listener),\n    removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\n  };\n}\n\nconst name = \"@firebase/app-check\";\nconst version = \"0.8.0\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\nconst RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js';\n\nfunction initializeV3(app, siteKey) {\n  const initialized = new Deferred();\n  const state = getStateReference(app);\n  state.reCAPTCHAState = {\n    initialized\n  };\n  const divId = makeDiv(app);\n  const grecaptcha = getRecaptcha(false);\n\n  if (!grecaptcha) {\n    loadReCAPTCHAV3Script(() => {\n      const grecaptcha = getRecaptcha(false);\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n\n  return initialized.promise;\n}\n\nfunction initializeEnterprise(app, siteKey) {\n  const initialized = new Deferred();\n  const state = getStateReference(app);\n  state.reCAPTCHAState = {\n    initialized\n  };\n  const divId = makeDiv(app);\n  const grecaptcha = getRecaptcha(true);\n\n  if (!grecaptcha) {\n    loadReCAPTCHAEnterpriseScript(() => {\n      const grecaptcha = getRecaptcha(true);\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n\n  return initialized.promise;\n}\n/**\r\n * Add listener to render the widget and resolve the promise when\r\n * the grecaptcha.ready() event fires.\r\n */\n\n\nfunction queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {\n  grecaptcha.ready(() => {\n    // Invisible widgets allow us to set a different siteKey for each widget,\n    // so we use them to support multiple apps\n    renderInvisibleWidget(app, siteKey, grecaptcha, container);\n    initialized.resolve(grecaptcha);\n  });\n}\n/**\r\n * Add invisible div to page.\r\n */\n\n\nfunction makeDiv(app) {\n  const divId = `fire_app_check_${app.name}`;\n  const invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n  document.body.appendChild(invisibleDiv);\n  return divId;\n}\n\nfunction getToken$1(_x9) {\n  return _getToken$2.apply(this, arguments);\n}\n/**\r\n *\r\n * @param app\r\n * @param container - Id of a HTML element.\r\n */\n\n\nfunction _getToken$2() {\n  _getToken$2 = _asyncToGenerator(function* (app) {\n    ensureActivated(app); // ensureActivated() guarantees that reCAPTCHAState is set\n\n    const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n    const recaptcha = yield reCAPTCHAState.initialized.promise;\n    return new Promise((resolve, _reject) => {\n      // Updated after initialization is complete.\n      const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n      recaptcha.ready(() => {\n        resolve( // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n        recaptcha.execute(reCAPTCHAState.widgetId, {\n          action: 'fire_app_check'\n        }));\n      });\n    });\n  });\n  return _getToken$2.apply(this, arguments);\n}\n\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\n  const widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible',\n    // Success callback - set state\n    callback: () => {\n      getStateReference(app).reCAPTCHAState.succeeded = true;\n    },\n    // Failure callback - set state\n    'error-callback': () => {\n      getStateReference(app).reCAPTCHAState.succeeded = false;\n    }\n  });\n  const state = getStateReference(app);\n  state.reCAPTCHAState = Object.assign(Object.assign({}, state.reCAPTCHAState), {\n    // state.reCAPTCHAState is set in the initialize()\n    widgetId\n  });\n}\n\nfunction loadReCAPTCHAV3Script(onload) {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\nfunction loadReCAPTCHAEnterpriseScript(onload) {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_ENTERPRISE_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\n\n\nclass ReCaptchaV3Provider {\n  /**\r\n   * Create a ReCaptchaV3Provider instance.\r\n   * @param siteKey - ReCAPTCHA V3 siteKey.\r\n   */\n  constructor(_siteKey) {\n    this._siteKey = _siteKey;\n    /**\r\n     * Throttle requests on certain error codes to prevent too many retries\r\n     * in a short time.\r\n     */\n\n    this._throttleData = null;\n  }\n  /**\r\n   * Returns an App Check token.\r\n   * @internal\r\n   */\n\n\n  getToken() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      throwIfThrottled(_this2._throttleData); // Top-level `getToken()` has already checked that App Check is initialized\n      // and therefore this._app and this._heartbeatServiceProvider are available.\n\n      const attestedClaimsToken = yield getToken$1(_this2._app).catch(_e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(\"recaptcha-error\"\n        /* AppCheckError.RECAPTCHA_ERROR */\n        );\n      }); // Check if a failure state was set by the recaptcha \"error-callback\".\n\n      if (!((_a = getStateReference(_this2._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n        throw ERROR_FACTORY.create(\"recaptcha-error\"\n        /* AppCheckError.RECAPTCHA_ERROR */\n        );\n      }\n\n      let result;\n\n      try {\n        result = yield exchangeToken(getExchangeRecaptchaV3TokenRequest(_this2._app, attestedClaimsToken), _this2._heartbeatServiceProvider);\n      } catch (e) {\n        if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\"\n        /* AppCheckError.FETCH_STATUS_ERROR */\n        )) {\n          _this2._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), _this2._throttleData);\n          throw ERROR_FACTORY.create(\"throttled\"\n          /* AppCheckError.THROTTLED */\n          , {\n            time: getDurationString(_this2._throttleData.allowRequestsAfter - Date.now()),\n            httpStatus: _this2._throttleData.httpStatus\n          });\n        } else {\n          throw e;\n        }\n      } // If successful, clear throttle data.\n\n\n      _this2._throttleData = null;\n      return result;\n    })();\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  initialize(app) {\n    this._app = app;\n    this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n    initializeV3(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  isEqual(otherProvider) {\n    if (otherProvider instanceof ReCaptchaV3Provider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n\n}\n/**\r\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\n\n\nclass ReCaptchaEnterpriseProvider {\n  /**\r\n   * Create a ReCaptchaEnterpriseProvider instance.\r\n   * @param siteKey - reCAPTCHA Enterprise score-based site key.\r\n   */\n  constructor(_siteKey) {\n    this._siteKey = _siteKey;\n    /**\r\n     * Throttle requests on certain error codes to prevent too many retries\r\n     * in a short time.\r\n     */\n\n    this._throttleData = null;\n  }\n  /**\r\n   * Returns an App Check token.\r\n   * @internal\r\n   */\n\n\n  getToken() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      throwIfThrottled(_this3._throttleData); // Top-level `getToken()` has already checked that App Check is initialized\n      // and therefore this._app and this._heartbeatServiceProvider are available.\n\n      const attestedClaimsToken = yield getToken$1(_this3._app).catch(_e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(\"recaptcha-error\"\n        /* AppCheckError.RECAPTCHA_ERROR */\n        );\n      }); // Check if a failure state was set by the recaptcha \"error-callback\".\n\n      if (!((_a = getStateReference(_this3._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n        throw ERROR_FACTORY.create(\"recaptcha-error\"\n        /* AppCheckError.RECAPTCHA_ERROR */\n        );\n      }\n\n      let result;\n\n      try {\n        result = yield exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(_this3._app, attestedClaimsToken), _this3._heartbeatServiceProvider);\n      } catch (e) {\n        if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\"\n        /* AppCheckError.FETCH_STATUS_ERROR */\n        )) {\n          _this3._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), _this3._throttleData);\n          throw ERROR_FACTORY.create(\"throttled\"\n          /* AppCheckError.THROTTLED */\n          , {\n            time: getDurationString(_this3._throttleData.allowRequestsAfter - Date.now()),\n            httpStatus: _this3._throttleData.httpStatus\n          });\n        } else {\n          throw e;\n        }\n      } // If successful, clear throttle data.\n\n\n      _this3._throttleData = null;\n      return result;\n    })();\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  initialize(app) {\n    this._app = app;\n    this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n    initializeEnterprise(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  isEqual(otherProvider) {\n    if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n\n}\n/**\r\n * Custom provider class.\r\n * @public\r\n */\n\n\nclass CustomProvider {\n  constructor(_customProviderOptions) {\n    this._customProviderOptions = _customProviderOptions;\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  getToken() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // custom provider\n      const customToken = yield _this4._customProviderOptions.getToken(); // Try to extract IAT from custom token, in case this token is not\n      // being newly issued. JWT timestamps are in seconds since epoch.\n\n      const issuedAtTimeSeconds = issuedAtTime(customToken.token); // Very basic validation, use current timestamp as IAT if JWT\n      // has no `iat` field or value is out of bounds.\n\n      const issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1000 : Date.now();\n      return Object.assign(Object.assign({}, customToken), {\n        issuedAtTimeMillis\n      });\n    })();\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  initialize(app) {\n    this._app = app;\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  isEqual(otherProvider) {\n    if (otherProvider instanceof CustomProvider) {\n      return this._customProviderOptions.getToken.toString() === otherProvider._customProviderOptions.getToken.toString();\n    } else {\n      return false;\n    }\n  }\n\n}\n/**\r\n * Set throttle data to block requests until after a certain time\r\n * depending on the failed request's status code.\r\n * @param httpStatus - Status code of failed request.\r\n * @param throttleData - `ThrottleData` object containing previous throttle\r\n * data state.\r\n * @returns Data about current throttle state and expiration time.\r\n */\n\n\nfunction setBackoff(httpStatus, throttleData) {\n  /**\r\n   * Block retries for 1 day for the following error codes:\r\n   *\r\n   * 404: Likely malformed URL.\r\n   *\r\n   * 403:\r\n   * - Attestation failed\r\n   * - Wrong API key\r\n   * - Project deleted\r\n   */\n  if (httpStatus === 404 || httpStatus === 403) {\n    return {\n      backoffCount: 1,\n      allowRequestsAfter: Date.now() + ONE_DAY,\n      httpStatus\n    };\n  } else {\n    /**\r\n     * For all other error codes, the time when it is ok to retry again\r\n     * is based on exponential backoff.\r\n     */\n    const backoffCount = throttleData ? throttleData.backoffCount : 0;\n    const backoffMillis = calculateBackoffMillis(backoffCount, 1000, 2);\n    return {\n      backoffCount: backoffCount + 1,\n      allowRequestsAfter: Date.now() + backoffMillis,\n      httpStatus\n    };\n  }\n}\n\nfunction throwIfThrottled(throttleData) {\n  if (throttleData) {\n    if (Date.now() - throttleData.allowRequestsAfter <= 0) {\n      // If before, throw.\n      throw ERROR_FACTORY.create(\"throttled\"\n      /* AppCheckError.THROTTLED */\n      , {\n        time: getDurationString(throttleData.allowRequestsAfter - Date.now()),\n        httpStatus: throttleData.httpStatus\n      });\n    }\n  }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Activate App Check for the given app. Can be called only once per app.\r\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\r\n * @param options - App Check initialization options\r\n * @public\r\n */\n\n\nfunction initializeAppCheck(app = getApp(), options) {\n  app = getModularInstance(app);\n\n  const provider = _getProvider(app, 'app-check'); // Ensure initializeDebugMode() is only called once.\n\n\n  if (!getDebugState().initialized) {\n    initializeDebugMode();\n  } // Log a message containing the debug token when `initializeAppCheck()`\n  // is called in debug mode.\n\n\n  if (isDebugMode()) {\n    // Do not block initialization to get the token for the message.\n    void getDebugToken().then(token => // Not using logger because I don't think we ever want this accidentally hidden.\n    console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));\n  }\n\n  if (provider.isInitialized()) {\n    const existingInstance = provider.getImmediate();\n    const initialOptions = provider.getOptions();\n\n    if (initialOptions.isTokenAutoRefreshEnabled === options.isTokenAutoRefreshEnabled && initialOptions.provider.isEqual(options.provider)) {\n      return existingInstance;\n    } else {\n      throw ERROR_FACTORY.create(\"already-initialized\"\n      /* AppCheckError.ALREADY_INITIALIZED */\n      , {\n        appName: app.name\n      });\n    }\n  }\n\n  const appCheck = provider.initialize({\n    options\n  });\n\n  _activate(app, options.provider, options.isTokenAutoRefreshEnabled); // If isTokenAutoRefreshEnabled is false, do not send any requests to the\n  // exchange endpoint without an explicit call from the user either directly\n  // or through another Firebase library (storage, functions, etc.)\n\n\n  if (getStateReference(app).isTokenAutoRefreshEnabled) {\n    // Adding a listener will start the refresher and fetch a token if needed.\n    // This gets a token ready and prevents a delay when an internal library\n    // requests the token.\n    // Listener function does not need to do anything, its base functionality\n    // of calling getToken() already fetches token and writes it to memory/storage.\n    addTokenListener(appCheck, \"INTERNAL\"\n    /* ListenerType.INTERNAL */\n    , () => {});\n  }\n\n  return appCheck;\n}\n/**\r\n * Activate App Check\r\n * @param app - Firebase app to activate App Check for.\r\n * @param provider - reCAPTCHA v3 provider or\r\n * custom token provider.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. If undefined, defaults to the\r\n * value of `app.automaticDataCollectionEnabled`, which defaults to\r\n * false and can be set in the app config.\r\n */\n\n\nfunction _activate(app, provider, isTokenAutoRefreshEnabled) {\n  // Create an entry in the APP_CHECK_STATES map. Further changes should\n  // directly mutate this object.\n  const state = setInitialState(app, Object.assign({}, DEFAULT_STATE));\n  state.activated = true;\n  state.provider = provider; // Read cached token from storage if it exists and store it in memory.\n\n  state.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\n    if (cachedToken && isValid(cachedToken)) {\n      state.token = cachedToken; // notify all listeners with the cached token\n\n      notifyTokenListeners(app, {\n        token: cachedToken.token\n      });\n    }\n\n    return cachedToken;\n  }); // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n\n  state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === undefined ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;\n  state.provider.initialize(app);\n}\n/**\r\n * Set whether App Check will automatically refresh tokens as needed.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. This overrides any value set\r\n * during `initializeAppCheck()`.\r\n * @public\r\n */\n\n\nfunction setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {\n  const app = appCheckInstance.app;\n  const state = getStateReference(app); // This will exist if any product libraries have called\n  // `addTokenListener()`\n\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n\n  state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled;\n}\n/**\r\n * Get the current App Check token. Attaches to the most recent\r\n * in-flight request if one is present. Returns null if no token\r\n * is present and no token requests are in-flight.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param forceRefresh - If true, will always try to fetch a fresh token.\r\n * If false, will use a cached token if found in storage.\r\n * @public\r\n */\n\n\nfunction getToken(_x10, _x11) {\n  return _getToken.apply(this, arguments);\n}\n/**\r\n * Requests a Firebase App Check token. This method should be used\r\n * only if you need to authorize requests to a non-Firebase backend.\r\n *\r\n * Returns limited-use tokens that are intended for use with your\r\n * non-Firebase backend endpoints that are protected with\r\n * <a href=\"https://firebase.google.com/docs/app-check/custom-resource-backend#replay-protection\">\r\n * Replay Protection</a>. This method\r\n * does not affect the token generation behavior of the\r\n * #getAppCheckToken() method.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @returns The limited use token.\r\n * @public\r\n */\n\n\nfunction _getToken() {\n  _getToken = _asyncToGenerator(function* (appCheckInstance, forceRefresh) {\n    const result = yield getToken$2(appCheckInstance, forceRefresh);\n\n    if (result.error) {\n      throw result.error;\n    }\n\n    return {\n      token: result.token\n    };\n  });\n  return _getToken.apply(this, arguments);\n}\n\nfunction getLimitedUseToken(appCheckInstance) {\n  return getLimitedUseToken$1(appCheckInstance);\n}\n/**\r\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\r\n * pattern for public use.\r\n */\n\n\nfunction onTokenChanged(appCheckInstance, onNextOrObserver, onError,\n/**\r\n * NOTE: Although an `onCompletion` callback can be provided, it will\r\n * never be called because the token stream is never-ending.\r\n * It is added only for API consistency with the observer pattern, which\r\n * we follow in JS APIs.\r\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nonCompletion) {\n  let nextFn = () => {};\n\n  let errorFn = () => {};\n\n  if (onNextOrObserver.next != null) {\n    nextFn = onNextOrObserver.next.bind(onNextOrObserver);\n  } else {\n    nextFn = onNextOrObserver;\n  }\n\n  if (onNextOrObserver.error != null) {\n    errorFn = onNextOrObserver.error.bind(onNextOrObserver);\n  } else if (onError) {\n    errorFn = onError;\n  }\n\n  addTokenListener(appCheckInstance, \"EXTERNAL\"\n  /* ListenerType.EXTERNAL */\n  , nextFn, errorFn);\n  return () => removeTokenListener(appCheckInstance.app, nextFn);\n}\n/**\r\n * Firebase App Check\r\n *\r\n * @packageDocumentation\r\n */\n\n\nconst APP_CHECK_NAME = 'app-check';\nconst APP_CHECK_NAME_INTERNAL = 'app-check-internal';\n\nfunction registerAppCheck() {\n  // The public interface\n  _registerComponent(new Component(APP_CHECK_NAME, container => {\n    // getImmediate for FirebaseApp will always succeed\n    const app = container.getProvider('app').getImmediate();\n    const heartbeatServiceProvider = container.getProvider('heartbeat');\n    return factory(app, heartbeatServiceProvider);\n  }, \"PUBLIC\"\n  /* ComponentType.PUBLIC */\n  ).setInstantiationMode(\"EXPLICIT\"\n  /* InstantiationMode.EXPLICIT */\n  )\n  /**\r\n   * Initialize app-check-internal after app-check is initialized to make AppCheck available to\r\n   * other Firebase SDKs\r\n   */\n  .setInstanceCreatedCallback((container, _identifier, _appcheckService) => {\n    container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\n  })); // The internal interface used by other Firebase products\n\n\n  _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, container => {\n    const appCheck = container.getProvider('app-check').getImmediate();\n    return internalFactory(appCheck);\n  }, \"PUBLIC\"\n  /* ComponentType.PUBLIC */\n  ).setInstantiationMode(\"EXPLICIT\"\n  /* InstantiationMode.EXPLICIT */\n  ));\n\n  registerVersion(name, version);\n}\n\nregisterAppCheck();\nexport { CustomProvider, ReCaptchaEnterpriseProvider, ReCaptchaV3Provider, getLimitedUseToken, getToken, initializeAppCheck, onTokenChanged, setTokenAutoRefreshEnabled };","map":{"version":3,"names":["_getProvider","getApp","_registerComponent","registerVersion","Component","Deferred","ErrorFactory","isIndexedDBAvailable","uuidv4","getGlobal","base64","issuedAtTime","calculateBackoffMillis","getModularInstance","Logger","APP_CHECK_STATES","Map","DEFAULT_STATE","activated","tokenObservers","DEBUG_STATE","initialized","enabled","getStateReference","app","get","Object","assign","setInitialState","state","set","getDebugState","BASE_ENDPOINT","EXCHANGE_RECAPTCHA_TOKEN_METHOD","EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD","EXCHANGE_DEBUG_TOKEN_METHOD","TOKEN_REFRESH_TIME","OFFSET_DURATION","RETRIAL_MIN_WAIT","RETRIAL_MAX_WAIT","ONE_DAY","Refresher","constructor","operation","retryPolicy","getWaitDuration","lowerBound","upperBound","pending","nextErrorWaitInterval","Error","start","process","catch","stop","reject","isRunning","hasSucceeded","sleep","getNextRun","resolve","promise","error","currentErrorWaitInterval","ms","Promise","setTimeout","ERRORS","ERROR_FACTORY","getRecaptcha","isEnterprise","_a","self","grecaptcha","enterprise","ensureActivated","create","appName","name","getDurationString","durationInMillis","totalSeconds","Math","round","days","floor","hours","minutes","seconds","result","pad","value","toString","exchangeToken","url","body","heartbeatServiceProvider","headers","heartbeatService","getImmediate","optional","heartbeatsHeader","getHeartbeatsHeader","options","method","JSON","stringify","response","fetch","originalError","originalErrorMessage","message","status","httpStatus","responseBody","json","match","ttl","isNaN","Number","timeToLiveAsNumber","now","Date","token","expireTimeMillis","issuedAtTimeMillis","getExchangeRecaptchaV3TokenRequest","reCAPTCHAToken","projectId","appId","apiKey","getExchangeRecaptchaEnterpriseTokenRequest","getExchangeDebugTokenRequest","debugToken","debug_token","DB_NAME","DB_VERSION","STORE_NAME","DEBUG_TOKEN_KEY","dbPromise","getDBPromise","request","indexedDB","open","onsuccess","event","target","onerror","onupgradeneeded","db","oldVersion","createObjectStore","keyPath","e","readTokenFromIndexedDB","read","computeKey","writeTokenToIndexedDB","write","writeDebugTokenToIndexedDB","readDebugTokenFromIndexedDB","key","transaction","store","objectStore","put","compositeKey","_event","undefined","logger","readTokenFromStorage","warn","writeTokenToStorage","readOrCreateDebugTokenFromStorage","existingDebugToken","_e","newToken","isDebugMode","debugState","getDebugToken","initializeDebugMode","globals","FIREBASE_APPCHECK_DEBUG_TOKEN","deferredToken","defaultTokenErrorData","formatDummyToken","tokenErrorData","encodeString","getToken$2","appCheck","forceRefresh","isValid","cachedToken","cachedTokenPromise","shouldCallListeners","exchangeTokenPromise","finally","tokenFromDebugExchange","provider","getToken","code","interopTokenResult","makeDummyTokenResult","internalError","notifyTokenListeners","getLimitedUseToken$1","addTokenListener","type","listener","onError","tokenObserver","next","validToken","then","initTokenRefresher","removeTokenListener","newObservers","filter","length","tokenRefresher","refresher","createTokenRefresher","isTokenAutoRefreshEnabled","nextRefreshTimeMillis","latestAllowableRefresh","min","max","observers","observer","AppCheckService","_delete","factory","internalFactory","getLimitedUseToken","version","RECAPTCHA_URL","RECAPTCHA_ENTERPRISE_URL","initializeV3","siteKey","reCAPTCHAState","divId","makeDiv","loadReCAPTCHAV3Script","queueWidgetRender","initializeEnterprise","loadReCAPTCHAEnterpriseScript","container","ready","renderInvisibleWidget","invisibleDiv","document","createElement","id","style","display","appendChild","getToken$1","recaptcha","_reject","execute","widgetId","action","render","sitekey","size","callback","succeeded","onload","script","src","head","ReCaptchaV3Provider","_siteKey","_throttleData","_b","_c","throwIfThrottled","attestedClaimsToken","_app","_heartbeatServiceProvider","includes","setBackoff","customData","time","allowRequestsAfter","initialize","isEqual","otherProvider","ReCaptchaEnterpriseProvider","CustomProvider","_customProviderOptions","customToken","issuedAtTimeSeconds","throttleData","backoffCount","backoffMillis","initializeAppCheck","console","log","isInitialized","existingInstance","initialOptions","getOptions","_activate","automaticDataCollectionEnabled","setTokenAutoRefreshEnabled","appCheckInstance","onTokenChanged","onNextOrObserver","onCompletion","nextFn","errorFn","bind","APP_CHECK_NAME","APP_CHECK_NAME_INTERNAL","registerAppCheck","getProvider","setInstantiationMode","setInstanceCreatedCallback","_identifier","_appcheckService"],"sources":["/Users/owtgvaolt210/RiderProjects/showering_app/showering_app/ClientApp/node_modules/@angular/fire/node_modules/@firebase/app-check/dist/esm/index.esm2017.js"],"sourcesContent":["import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { Deferred, ErrorFactory, isIndexedDBAvailable, uuidv4, getGlobal, base64, issuedAtTime, calculateBackoffMillis, getModularInstance } from '@firebase/util';\nimport { Logger } from '@firebase/logger';\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst APP_CHECK_STATES = new Map();\r\nconst DEFAULT_STATE = {\r\n    activated: false,\r\n    tokenObservers: []\r\n};\r\nconst DEBUG_STATE = {\r\n    initialized: false,\r\n    enabled: false\r\n};\r\n/**\r\n * Gets a reference to the state object.\r\n */\r\nfunction getStateReference(app) {\r\n    return APP_CHECK_STATES.get(app) || Object.assign({}, DEFAULT_STATE);\r\n}\r\n/**\r\n * Set once on initialization. The map should hold the same reference to the\r\n * same object until this entry is deleted.\r\n */\r\nfunction setInitialState(app, state) {\r\n    APP_CHECK_STATES.set(app, state);\r\n    return APP_CHECK_STATES.get(app);\r\n}\r\nfunction getDebugState() {\r\n    return DEBUG_STATE;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1';\r\nconst EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaV3Token';\r\nconst EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = 'exchangeRecaptchaEnterpriseToken';\r\nconst EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\r\nconst TOKEN_REFRESH_TIME = {\r\n    /**\r\n     * The offset time before token natural expiration to run the refresh.\r\n     * This is currently 5 minutes.\r\n     */\r\n    OFFSET_DURATION: 5 * 60 * 1000,\r\n    /**\r\n     * This is the first retrial wait after an error. This is currently\r\n     * 30 seconds.\r\n     */\r\n    RETRIAL_MIN_WAIT: 30 * 1000,\r\n    /**\r\n     * This is the maximum retrial wait, currently 16 minutes.\r\n     */\r\n    RETRIAL_MAX_WAIT: 16 * 60 * 1000\r\n};\r\n/**\r\n * One day in millis, for certain error code backoffs.\r\n */\r\nconst ONE_DAY = 24 * 60 * 60 * 1000;\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Port from auth proactiverefresh.js\r\n *\r\n */\r\n// TODO: move it to @firebase/util?\r\n// TODO: allow to config whether refresh should happen in the background\r\nclass Refresher {\r\n    constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\r\n        this.operation = operation;\r\n        this.retryPolicy = retryPolicy;\r\n        this.getWaitDuration = getWaitDuration;\r\n        this.lowerBound = lowerBound;\r\n        this.upperBound = upperBound;\r\n        this.pending = null;\r\n        this.nextErrorWaitInterval = lowerBound;\r\n        if (lowerBound > upperBound) {\r\n            throw new Error('Proactive refresh lower bound greater than upper bound!');\r\n        }\r\n    }\r\n    start() {\r\n        this.nextErrorWaitInterval = this.lowerBound;\r\n        this.process(true).catch(() => {\r\n            /* we don't care about the result */\r\n        });\r\n    }\r\n    stop() {\r\n        if (this.pending) {\r\n            this.pending.reject('cancelled');\r\n            this.pending = null;\r\n        }\r\n    }\r\n    isRunning() {\r\n        return !!this.pending;\r\n    }\r\n    async process(hasSucceeded) {\r\n        this.stop();\r\n        try {\r\n            this.pending = new Deferred();\r\n            await sleep(this.getNextRun(hasSucceeded));\r\n            // Why do we resolve a promise, then immediate wait for it?\r\n            // We do it to make the promise chain cancellable.\r\n            // We can call stop() which rejects the promise before the following line execute, which makes\r\n            // the code jump to the catch block.\r\n            // TODO: unit test this\r\n            this.pending.resolve();\r\n            await this.pending.promise;\r\n            this.pending = new Deferred();\r\n            await this.operation();\r\n            this.pending.resolve();\r\n            await this.pending.promise;\r\n            this.process(true).catch(() => {\r\n                /* we don't care about the result */\r\n            });\r\n        }\r\n        catch (error) {\r\n            if (this.retryPolicy(error)) {\r\n                this.process(false).catch(() => {\r\n                    /* we don't care about the result */\r\n                });\r\n            }\r\n            else {\r\n                this.stop();\r\n            }\r\n        }\r\n    }\r\n    getNextRun(hasSucceeded) {\r\n        if (hasSucceeded) {\r\n            // If last operation succeeded, reset next error wait interval and return\r\n            // the default wait duration.\r\n            this.nextErrorWaitInterval = this.lowerBound;\r\n            // Return typical wait duration interval after a successful operation.\r\n            return this.getWaitDuration();\r\n        }\r\n        else {\r\n            // Get next error wait interval.\r\n            const currentErrorWaitInterval = this.nextErrorWaitInterval;\r\n            // Double interval for next consecutive error.\r\n            this.nextErrorWaitInterval *= 2;\r\n            // Make sure next wait interval does not exceed the maximum upper bound.\r\n            if (this.nextErrorWaitInterval > this.upperBound) {\r\n                this.nextErrorWaitInterval = this.upperBound;\r\n            }\r\n            return currentErrorWaitInterval;\r\n        }\r\n    }\r\n}\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */]: 'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' +\r\n        'different options. To avoid this error, call initializeAppCheck() with the ' +\r\n        'same options as when it was originally called. This will return the ' +\r\n        'already initialized instance.',\r\n    [\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */]: 'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' +\r\n        'Call initializeAppCheck() before instantiating other Firebase services.',\r\n    [\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */]: 'Fetch failed to connect to a network. Check Internet connection. ' +\r\n        'Original error: {$originalErrorMessage}.',\r\n    [\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */]: 'Fetch client could not parse response.' +\r\n        ' Original error: {$originalErrorMessage}.',\r\n    [\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\r\n    [\"storage-open\" /* AppCheckError.STORAGE_OPEN */]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\r\n    [\"storage-get\" /* AppCheckError.STORAGE_GET */]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\r\n    [\"storage-set\" /* AppCheckError.STORAGE_WRITE */]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\r\n    [\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */]: 'ReCAPTCHA error.',\r\n    [\"throttled\" /* AppCheckError.THROTTLED */]: `Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}`\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory('appCheck', 'AppCheck', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getRecaptcha(isEnterprise = false) {\r\n    var _a;\r\n    if (isEnterprise) {\r\n        return (_a = self.grecaptcha) === null || _a === void 0 ? void 0 : _a.enterprise;\r\n    }\r\n    return self.grecaptcha;\r\n}\r\nfunction ensureActivated(app) {\r\n    if (!getStateReference(app).activated) {\r\n        throw ERROR_FACTORY.create(\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */, {\r\n            appName: app.name\r\n        });\r\n    }\r\n}\r\nfunction getDurationString(durationInMillis) {\r\n    const totalSeconds = Math.round(durationInMillis / 1000);\r\n    const days = Math.floor(totalSeconds / (3600 * 24));\r\n    const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);\r\n    const minutes = Math.floor((totalSeconds - days * 3600 * 24 - hours * 3600) / 60);\r\n    const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;\r\n    let result = '';\r\n    if (days) {\r\n        result += pad(days) + 'd:';\r\n    }\r\n    if (hours) {\r\n        result += pad(hours) + 'h:';\r\n    }\r\n    result += pad(minutes) + 'm:' + pad(seconds) + 's';\r\n    return result;\r\n}\r\nfunction pad(value) {\r\n    if (value === 0) {\r\n        return '00';\r\n    }\r\n    return value >= 10 ? value.toString() : '0' + value;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function exchangeToken({ url, body }, heartbeatServiceProvider) {\r\n    const headers = {\r\n        'Content-Type': 'application/json'\r\n    };\r\n    // If heartbeat service exists, add heartbeat header string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers['X-Firebase-Client'] = heartbeatsHeader;\r\n        }\r\n    }\r\n    const options = {\r\n        method: 'POST',\r\n        body: JSON.stringify(body),\r\n        headers\r\n    };\r\n    let response;\r\n    try {\r\n        response = await fetch(url, options);\r\n    }\r\n    catch (originalError) {\r\n        throw ERROR_FACTORY.create(\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */, {\r\n            originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\r\n        });\r\n    }\r\n    if (response.status !== 200) {\r\n        throw ERROR_FACTORY.create(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */, {\r\n            httpStatus: response.status\r\n        });\r\n    }\r\n    let responseBody;\r\n    try {\r\n        // JSON parsing throws SyntaxError if the response body isn't a JSON string.\r\n        responseBody = await response.json();\r\n    }\r\n    catch (originalError) {\r\n        throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\r\n            originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\r\n        });\r\n    }\r\n    // Protobuf duration format.\r\n    // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\r\n    const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\r\n    if (!match || !match[2] || isNaN(Number(match[1]))) {\r\n        throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\r\n            originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration ` +\r\n                `format: ${responseBody.ttl}`\r\n        });\r\n    }\r\n    const timeToLiveAsNumber = Number(match[1]) * 1000;\r\n    const now = Date.now();\r\n    return {\r\n        token: responseBody.token,\r\n        expireTimeMillis: now + timeToLiveAsNumber,\r\n        issuedAtTimeMillis: now\r\n    };\r\n}\r\nfunction getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {\r\n    const { projectId, appId, apiKey } = app.options;\r\n    return {\r\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\r\n        body: {\r\n            'recaptcha_v3_token': reCAPTCHAToken\r\n        }\r\n    };\r\n}\r\nfunction getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {\r\n    const { projectId, appId, apiKey } = app.options;\r\n    return {\r\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\r\n        body: {\r\n            'recaptcha_enterprise_token': reCAPTCHAToken\r\n        }\r\n    };\r\n}\r\nfunction getExchangeDebugTokenRequest(app, debugToken) {\r\n    const { projectId, appId, apiKey } = app.options;\r\n    return {\r\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\r\n        body: {\r\n            // eslint-disable-next-line\r\n            debug_token: debugToken\r\n        }\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DB_NAME = 'firebase-app-check-database';\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = 'firebase-app-check-store';\r\nconst DEBUG_TOKEN_KEY = 'debug-token';\r\nlet dbPromise = null;\r\nfunction getDBPromise() {\r\n    if (dbPromise) {\r\n        return dbPromise;\r\n    }\r\n    dbPromise = new Promise((resolve, reject) => {\r\n        try {\r\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n            request.onsuccess = event => {\r\n                resolve(event.target.result);\r\n            };\r\n            request.onerror = event => {\r\n                var _a;\r\n                reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\r\n                    originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\r\n                }));\r\n            };\r\n            request.onupgradeneeded = event => {\r\n                const db = event.target.result;\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (event.oldVersion) {\r\n                    case 0:\r\n                        db.createObjectStore(STORE_NAME, {\r\n                            keyPath: 'compositeKey'\r\n                        });\r\n                }\r\n            };\r\n        }\r\n        catch (e) {\r\n            reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            }));\r\n        }\r\n    });\r\n    return dbPromise;\r\n}\r\nfunction readTokenFromIndexedDB(app) {\r\n    return read(computeKey(app));\r\n}\r\nfunction writeTokenToIndexedDB(app, token) {\r\n    return write(computeKey(app), token);\r\n}\r\nfunction writeDebugTokenToIndexedDB(token) {\r\n    return write(DEBUG_TOKEN_KEY, token);\r\n}\r\nfunction readDebugTokenFromIndexedDB() {\r\n    return read(DEBUG_TOKEN_KEY);\r\n}\r\nasync function write(key, value) {\r\n    const db = await getDBPromise();\r\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.put({\r\n        compositeKey: key,\r\n        value\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        request.onsuccess = _event => {\r\n            resolve();\r\n        };\r\n        transaction.onerror = event => {\r\n            var _a;\r\n            reject(ERROR_FACTORY.create(\"storage-set\" /* AppCheckError.STORAGE_WRITE */, {\r\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\r\n            }));\r\n        };\r\n    });\r\n}\r\nasync function read(key) {\r\n    const db = await getDBPromise();\r\n    const transaction = db.transaction(STORE_NAME, 'readonly');\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.get(key);\r\n    return new Promise((resolve, reject) => {\r\n        request.onsuccess = event => {\r\n            const result = event.target.result;\r\n            if (result) {\r\n                resolve(result.value);\r\n            }\r\n            else {\r\n                resolve(undefined);\r\n            }\r\n        };\r\n        transaction.onerror = event => {\r\n            var _a;\r\n            reject(ERROR_FACTORY.create(\"storage-get\" /* AppCheckError.STORAGE_GET */, {\r\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\r\n            }));\r\n        };\r\n    });\r\n}\r\nfunction computeKey(app) {\r\n    return `${app.options.appId}-${app.name}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new Logger('@firebase/app-check');\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\r\n */\r\nasync function readTokenFromStorage(app) {\r\n    if (isIndexedDBAvailable()) {\r\n        let token = undefined;\r\n        try {\r\n            token = await readTokenFromIndexedDB(app);\r\n        }\r\n        catch (e) {\r\n            // swallow the error and return undefined\r\n            logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\r\n        }\r\n        return token;\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\r\n */\r\nfunction writeTokenToStorage(app, token) {\r\n    if (isIndexedDBAvailable()) {\r\n        return writeTokenToIndexedDB(app, token).catch(e => {\r\n            // swallow the error and resolve the promise\r\n            logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\r\n        });\r\n    }\r\n    return Promise.resolve();\r\n}\r\nasync function readOrCreateDebugTokenFromStorage() {\r\n    /**\r\n     * Theoretically race condition can happen if we read, then write in 2 separate transactions.\r\n     * But it won't happen here, because this function will be called exactly once.\r\n     */\r\n    let existingDebugToken = undefined;\r\n    try {\r\n        existingDebugToken = await readDebugTokenFromIndexedDB();\r\n    }\r\n    catch (_e) {\r\n        // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\r\n    }\r\n    if (!existingDebugToken) {\r\n        // create a new debug token\r\n        const newToken = uuidv4();\r\n        // We don't need to block on writing to indexeddb\r\n        // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\r\n        // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\r\n        // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\r\n        // You should switch to a different browser that supports indexeddb\r\n        writeDebugTokenToIndexedDB(newToken).catch(e => logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));\r\n        return newToken;\r\n    }\r\n    else {\r\n        return existingDebugToken;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isDebugMode() {\r\n    const debugState = getDebugState();\r\n    return debugState.enabled;\r\n}\r\nasync function getDebugToken() {\r\n    const state = getDebugState();\r\n    if (state.enabled && state.token) {\r\n        return state.token.promise;\r\n    }\r\n    else {\r\n        // should not happen!\r\n        throw Error(`\n            Can't get debug token in production mode.\n        `);\r\n    }\r\n}\r\nfunction initializeDebugMode() {\r\n    const globals = getGlobal();\r\n    const debugState = getDebugState();\r\n    // Set to true if this function has been called, whether or not\r\n    // it enabled debug mode.\r\n    debugState.initialized = true;\r\n    if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' &&\r\n        globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\r\n        return;\r\n    }\r\n    debugState.enabled = true;\r\n    const deferredToken = new Deferred();\r\n    debugState.token = deferredToken;\r\n    if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\r\n        deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\r\n    }\r\n    else {\r\n        deferredToken.resolve(readOrCreateDebugTokenFromStorage());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Initial hardcoded value agreed upon across platforms for initial launch.\r\n// Format left open for possible dynamic error values and other fields in the future.\r\nconst defaultTokenErrorData = { error: 'UNKNOWN_ERROR' };\r\n/**\r\n * Stringify and base64 encode token error data.\r\n *\r\n * @param tokenError Error data, currently hardcoded.\r\n */\r\nfunction formatDummyToken(tokenErrorData) {\r\n    return base64.encodeString(JSON.stringify(tokenErrorData), \r\n    /* webSafe= */ false);\r\n}\r\n/**\r\n * This function always resolves.\r\n * The result will contain an error field if there is any error.\r\n * In case there is an error, the token field in the result will be populated with a dummy value\r\n */\r\nasync function getToken$2(appCheck, forceRefresh = false) {\r\n    const app = appCheck.app;\r\n    ensureActivated(app);\r\n    const state = getStateReference(app);\r\n    /**\r\n     * First check if there is a token in memory from a previous `getToken()` call.\r\n     */\r\n    let token = state.token;\r\n    let error = undefined;\r\n    /**\r\n     * If an invalid token was found in memory, clear token from\r\n     * memory and unset the local variable `token`.\r\n     */\r\n    if (token && !isValid(token)) {\r\n        state.token = undefined;\r\n        token = undefined;\r\n    }\r\n    /**\r\n     * If there is no valid token in memory, try to load token from indexedDB.\r\n     */\r\n    if (!token) {\r\n        // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\r\n        const cachedToken = await state.cachedTokenPromise;\r\n        if (cachedToken) {\r\n            if (isValid(cachedToken)) {\r\n                token = cachedToken;\r\n            }\r\n            else {\r\n                // If there was an invalid token in the indexedDB cache, clear it.\r\n                await writeTokenToStorage(app, undefined);\r\n            }\r\n        }\r\n    }\r\n    // Return the cached token (from either memory or indexedDB) if it's valid\r\n    if (!forceRefresh && token && isValid(token)) {\r\n        return {\r\n            token: token.token\r\n        };\r\n    }\r\n    // Only set to true if this `getToken()` call is making the actual\r\n    // REST call to the exchange endpoint, versus waiting for an already\r\n    // in-flight call (see debug and regular exchange endpoint paths below)\r\n    let shouldCallListeners = false;\r\n    /**\r\n     * DEBUG MODE\r\n     * If debug mode is set, and there is no cached token, fetch a new App\r\n     * Check token using the debug token, and return it directly.\r\n     */\r\n    if (isDebugMode()) {\r\n        // Avoid making another call to the exchange endpoint if one is in flight.\r\n        if (!state.exchangeTokenPromise) {\r\n            state.exchangeTokenPromise = exchangeToken(getExchangeDebugTokenRequest(app, await getDebugToken()), appCheck.heartbeatServiceProvider).finally(() => {\r\n                // Clear promise when settled - either resolved or rejected.\r\n                state.exchangeTokenPromise = undefined;\r\n            });\r\n            shouldCallListeners = true;\r\n        }\r\n        const tokenFromDebugExchange = await state.exchangeTokenPromise;\r\n        // Write debug token to indexedDB.\r\n        await writeTokenToStorage(app, tokenFromDebugExchange);\r\n        // Write debug token to state.\r\n        state.token = tokenFromDebugExchange;\r\n        return { token: tokenFromDebugExchange.token };\r\n    }\r\n    /**\r\n     * There are no valid tokens in memory or indexedDB and we are not in\r\n     * debug mode.\r\n     * Request a new token from the exchange endpoint.\r\n     */\r\n    try {\r\n        // Avoid making another call to the exchange endpoint if one is in flight.\r\n        if (!state.exchangeTokenPromise) {\r\n            // state.provider is populated in initializeAppCheck()\r\n            // ensureActivated() at the top of this function checks that\r\n            // initializeAppCheck() has been called.\r\n            state.exchangeTokenPromise = state.provider.getToken().finally(() => {\r\n                // Clear promise when settled - either resolved or rejected.\r\n                state.exchangeTokenPromise = undefined;\r\n            });\r\n            shouldCallListeners = true;\r\n        }\r\n        token = await getStateReference(app).exchangeTokenPromise;\r\n    }\r\n    catch (e) {\r\n        if (e.code === `appCheck/${\"throttled\" /* AppCheckError.THROTTLED */}`) {\r\n            // Warn if throttled, but do not treat it as an error.\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            // `getToken()` should never throw, but logging error text to console will aid debugging.\r\n            logger.error(e);\r\n        }\r\n        // Always save error to be added to dummy token.\r\n        error = e;\r\n    }\r\n    let interopTokenResult;\r\n    if (!token) {\r\n        // If token is undefined, there must be an error.\r\n        // Return a dummy token along with the error.\r\n        interopTokenResult = makeDummyTokenResult(error);\r\n    }\r\n    else if (error) {\r\n        if (isValid(token)) {\r\n            // It's also possible a valid token exists, but there's also an error.\r\n            // (Such as if the token is almost expired, tries to refresh, and\r\n            // the exchange request fails.)\r\n            // We add a special error property here so that the refresher will\r\n            // count this as a failed attempt and use the backoff instead of\r\n            // retrying repeatedly with no delay, but any 3P listeners will not\r\n            // be hindered in getting the still-valid token.\r\n            interopTokenResult = {\r\n                token: token.token,\r\n                internalError: error\r\n            };\r\n        }\r\n        else {\r\n            // No invalid tokens should make it to this step. Memory and cached tokens\r\n            // are checked. Other tokens are from fresh exchanges. But just in case.\r\n            interopTokenResult = makeDummyTokenResult(error);\r\n        }\r\n    }\r\n    else {\r\n        interopTokenResult = {\r\n            token: token.token\r\n        };\r\n        // write the new token to the memory state as well as the persistent storage.\r\n        // Only do it if we got a valid new token\r\n        state.token = token;\r\n        await writeTokenToStorage(app, token);\r\n    }\r\n    if (shouldCallListeners) {\r\n        notifyTokenListeners(app, interopTokenResult);\r\n    }\r\n    return interopTokenResult;\r\n}\r\n/**\r\n * Internal API for limited use tokens. Skips all FAC state and simply calls\r\n * the underlying provider.\r\n */\r\nasync function getLimitedUseToken$1(appCheck) {\r\n    const app = appCheck.app;\r\n    ensureActivated(app);\r\n    const { provider } = getStateReference(app);\r\n    if (isDebugMode()) {\r\n        const debugToken = await getDebugToken();\r\n        const { token } = await exchangeToken(getExchangeDebugTokenRequest(app, debugToken), appCheck.heartbeatServiceProvider);\r\n        return { token };\r\n    }\r\n    else {\r\n        // provider is definitely valid since we ensure AppCheck was activated\r\n        const { token } = await provider.getToken();\r\n        return { token };\r\n    }\r\n}\r\nfunction addTokenListener(appCheck, type, listener, onError) {\r\n    const { app } = appCheck;\r\n    const state = getStateReference(app);\r\n    const tokenObserver = {\r\n        next: listener,\r\n        error: onError,\r\n        type\r\n    };\r\n    state.tokenObservers = [...state.tokenObservers, tokenObserver];\r\n    // Invoke the listener async immediately if there is a valid token\r\n    // in memory.\r\n    if (state.token && isValid(state.token)) {\r\n        const validToken = state.token;\r\n        Promise.resolve()\r\n            .then(() => {\r\n            listener({ token: validToken.token });\r\n            initTokenRefresher(appCheck);\r\n        })\r\n            .catch(() => {\r\n            /* we don't care about exceptions thrown in listeners */\r\n        });\r\n    }\r\n    /**\r\n     * Wait for any cached token promise to resolve before starting the token\r\n     * refresher. The refresher checks to see if there is an existing token\r\n     * in state and calls the exchange endpoint if not. We should first let the\r\n     * IndexedDB check have a chance to populate state if it can.\r\n     *\r\n     * Listener call isn't needed here because cachedTokenPromise will call any\r\n     * listeners that exist when it resolves.\r\n     */\r\n    // state.cachedTokenPromise is always populated in `activate()`.\r\n    void state.cachedTokenPromise.then(() => initTokenRefresher(appCheck));\r\n}\r\nfunction removeTokenListener(app, listener) {\r\n    const state = getStateReference(app);\r\n    const newObservers = state.tokenObservers.filter(tokenObserver => tokenObserver.next !== listener);\r\n    if (newObservers.length === 0 &&\r\n        state.tokenRefresher &&\r\n        state.tokenRefresher.isRunning()) {\r\n        state.tokenRefresher.stop();\r\n    }\r\n    state.tokenObservers = newObservers;\r\n}\r\n/**\r\n * Logic to create and start refresher as needed.\r\n */\r\nfunction initTokenRefresher(appCheck) {\r\n    const { app } = appCheck;\r\n    const state = getStateReference(app);\r\n    // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\r\n    // is not true.\r\n    let refresher = state.tokenRefresher;\r\n    if (!refresher) {\r\n        refresher = createTokenRefresher(appCheck);\r\n        state.tokenRefresher = refresher;\r\n    }\r\n    if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {\r\n        refresher.start();\r\n    }\r\n}\r\nfunction createTokenRefresher(appCheck) {\r\n    const { app } = appCheck;\r\n    return new Refresher(\r\n    // Keep in mind when this fails for any reason other than the ones\r\n    // for which we should retry, it will effectively stop the proactive refresh.\r\n    async () => {\r\n        const state = getStateReference(app);\r\n        // If there is no token, we will try to load it from storage and use it\r\n        // If there is a token, we force refresh it because we know it's going to expire soon\r\n        let result;\r\n        if (!state.token) {\r\n            result = await getToken$2(appCheck);\r\n        }\r\n        else {\r\n            result = await getToken$2(appCheck, true);\r\n        }\r\n        /**\r\n         * getToken() always resolves. In case the result has an error field defined, it means\r\n         * the operation failed, and we should retry.\r\n         */\r\n        if (result.error) {\r\n            throw result.error;\r\n        }\r\n        /**\r\n         * A special `internalError` field reflects that there was an error\r\n         * getting a new token from the exchange endpoint, but there's still a\r\n         * previous token that's valid for now and this should be passed to 2P/3P\r\n         * requests for a token. But we want this callback (`this.operation` in\r\n         * `Refresher`) to throw in order to kick off the Refresher's retry\r\n         * backoff. (Setting `hasSucceeded` to false.)\r\n         */\r\n        if (result.internalError) {\r\n            throw result.internalError;\r\n        }\r\n    }, () => {\r\n        return true;\r\n    }, () => {\r\n        const state = getStateReference(app);\r\n        if (state.token) {\r\n            // issuedAtTime + (50% * total TTL) + 5 minutes\r\n            let nextRefreshTimeMillis = state.token.issuedAtTimeMillis +\r\n                (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) *\r\n                    0.5 +\r\n                5 * 60 * 1000;\r\n            // Do not allow refresh time to be past (expireTime - 5 minutes)\r\n            const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\r\n            nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\r\n            return Math.max(0, nextRefreshTimeMillis - Date.now());\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\r\n}\r\nfunction notifyTokenListeners(app, token) {\r\n    const observers = getStateReference(app).tokenObservers;\r\n    for (const observer of observers) {\r\n        try {\r\n            if (observer.type === \"EXTERNAL\" /* ListenerType.EXTERNAL */ && token.error != null) {\r\n                // If this listener was added by a 3P call, send any token error to\r\n                // the supplied error handler. A 3P observer always has an error\r\n                // handler.\r\n                observer.error(token.error);\r\n            }\r\n            else {\r\n                // If the token has no error field, always return the token.\r\n                // If this is a 2P listener, return the token, whether or not it\r\n                // has an error field.\r\n                observer.next(token);\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Errors in the listener function itself are always ignored.\r\n        }\r\n    }\r\n}\r\nfunction isValid(token) {\r\n    return token.expireTimeMillis - Date.now() > 0;\r\n}\r\nfunction makeDummyTokenResult(error) {\r\n    return {\r\n        token: formatDummyToken(defaultTokenErrorData),\r\n        error\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * AppCheck Service class.\r\n */\r\nclass AppCheckService {\r\n    constructor(app, heartbeatServiceProvider) {\r\n        this.app = app;\r\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\r\n    }\r\n    _delete() {\r\n        const { tokenObservers } = getStateReference(this.app);\r\n        for (const tokenObserver of tokenObservers) {\r\n            removeTokenListener(this.app, tokenObserver.next);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n}\r\nfunction factory(app, heartbeatServiceProvider) {\r\n    return new AppCheckService(app, heartbeatServiceProvider);\r\n}\r\nfunction internalFactory(appCheck) {\r\n    return {\r\n        getToken: forceRefresh => getToken$2(appCheck, forceRefresh),\r\n        getLimitedUseToken: () => getLimitedUseToken$1(appCheck),\r\n        addTokenListener: listener => addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, listener),\r\n        removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\r\n    };\r\n}\n\nconst name = \"@firebase/app-check\";\nconst version = \"0.8.0\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\r\nconst RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js';\r\nfunction initializeV3(app, siteKey) {\r\n    const initialized = new Deferred();\r\n    const state = getStateReference(app);\r\n    state.reCAPTCHAState = { initialized };\r\n    const divId = makeDiv(app);\r\n    const grecaptcha = getRecaptcha(false);\r\n    if (!grecaptcha) {\r\n        loadReCAPTCHAV3Script(() => {\r\n            const grecaptcha = getRecaptcha(false);\r\n            if (!grecaptcha) {\r\n                // it shouldn't happen.\r\n                throw new Error('no recaptcha');\r\n            }\r\n            queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\r\n        });\r\n    }\r\n    else {\r\n        queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\r\n    }\r\n    return initialized.promise;\r\n}\r\nfunction initializeEnterprise(app, siteKey) {\r\n    const initialized = new Deferred();\r\n    const state = getStateReference(app);\r\n    state.reCAPTCHAState = { initialized };\r\n    const divId = makeDiv(app);\r\n    const grecaptcha = getRecaptcha(true);\r\n    if (!grecaptcha) {\r\n        loadReCAPTCHAEnterpriseScript(() => {\r\n            const grecaptcha = getRecaptcha(true);\r\n            if (!grecaptcha) {\r\n                // it shouldn't happen.\r\n                throw new Error('no recaptcha');\r\n            }\r\n            queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\r\n        });\r\n    }\r\n    else {\r\n        queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\r\n    }\r\n    return initialized.promise;\r\n}\r\n/**\r\n * Add listener to render the widget and resolve the promise when\r\n * the grecaptcha.ready() event fires.\r\n */\r\nfunction queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {\r\n    grecaptcha.ready(() => {\r\n        // Invisible widgets allow us to set a different siteKey for each widget,\r\n        // so we use them to support multiple apps\r\n        renderInvisibleWidget(app, siteKey, grecaptcha, container);\r\n        initialized.resolve(grecaptcha);\r\n    });\r\n}\r\n/**\r\n * Add invisible div to page.\r\n */\r\nfunction makeDiv(app) {\r\n    const divId = `fire_app_check_${app.name}`;\r\n    const invisibleDiv = document.createElement('div');\r\n    invisibleDiv.id = divId;\r\n    invisibleDiv.style.display = 'none';\r\n    document.body.appendChild(invisibleDiv);\r\n    return divId;\r\n}\r\nasync function getToken$1(app) {\r\n    ensureActivated(app);\r\n    // ensureActivated() guarantees that reCAPTCHAState is set\r\n    const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\r\n    const recaptcha = await reCAPTCHAState.initialized.promise;\r\n    return new Promise((resolve, _reject) => {\r\n        // Updated after initialization is complete.\r\n        const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\r\n        recaptcha.ready(() => {\r\n            resolve(\r\n            // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\r\n            recaptcha.execute(reCAPTCHAState.widgetId, {\r\n                action: 'fire_app_check'\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n *\r\n * @param app\r\n * @param container - Id of a HTML element.\r\n */\r\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\r\n    const widgetId = grecaptcha.render(container, {\r\n        sitekey: siteKey,\r\n        size: 'invisible',\r\n        // Success callback - set state\r\n        callback: () => {\r\n            getStateReference(app).reCAPTCHAState.succeeded = true;\r\n        },\r\n        // Failure callback - set state\r\n        'error-callback': () => {\r\n            getStateReference(app).reCAPTCHAState.succeeded = false;\r\n        }\r\n    });\r\n    const state = getStateReference(app);\r\n    state.reCAPTCHAState = Object.assign(Object.assign({}, state.reCAPTCHAState), { // state.reCAPTCHAState is set in the initialize()\r\n        widgetId });\r\n}\r\nfunction loadReCAPTCHAV3Script(onload) {\r\n    const script = document.createElement('script');\r\n    script.src = RECAPTCHA_URL;\r\n    script.onload = onload;\r\n    document.head.appendChild(script);\r\n}\r\nfunction loadReCAPTCHAEnterpriseScript(onload) {\r\n    const script = document.createElement('script');\r\n    script.src = RECAPTCHA_ENTERPRISE_URL;\r\n    script.onload = onload;\r\n    document.head.appendChild(script);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\r\nclass ReCaptchaV3Provider {\r\n    /**\r\n     * Create a ReCaptchaV3Provider instance.\r\n     * @param siteKey - ReCAPTCHA V3 siteKey.\r\n     */\r\n    constructor(_siteKey) {\r\n        this._siteKey = _siteKey;\r\n        /**\r\n         * Throttle requests on certain error codes to prevent too many retries\r\n         * in a short time.\r\n         */\r\n        this._throttleData = null;\r\n    }\r\n    /**\r\n     * Returns an App Check token.\r\n     * @internal\r\n     */\r\n    async getToken() {\r\n        var _a, _b, _c;\r\n        throwIfThrottled(this._throttleData);\r\n        // Top-level `getToken()` has already checked that App Check is initialized\r\n        // and therefore this._app and this._heartbeatServiceProvider are available.\r\n        const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\r\n            // reCaptcha.execute() throws null which is not very descriptive.\r\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\r\n        });\r\n        // Check if a failure state was set by the recaptcha \"error-callback\".\r\n        if (!((_a = getStateReference(this._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\r\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\r\n        }\r\n        let result;\r\n        try {\r\n            result = await exchangeToken(getExchangeRecaptchaV3TokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);\r\n        }\r\n        catch (e) {\r\n            if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\r\n                this._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), this._throttleData);\r\n                throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\r\n                    time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),\r\n                    httpStatus: this._throttleData.httpStatus\r\n                });\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        // If successful, clear throttle data.\r\n        this._throttleData = null;\r\n        return result;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    initialize(app) {\r\n        this._app = app;\r\n        this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\r\n        initializeV3(app, this._siteKey).catch(() => {\r\n            /* we don't care about the initialization result */\r\n        });\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    isEqual(otherProvider) {\r\n        if (otherProvider instanceof ReCaptchaV3Provider) {\r\n            return this._siteKey === otherProvider._siteKey;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n/**\r\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\r\nclass ReCaptchaEnterpriseProvider {\r\n    /**\r\n     * Create a ReCaptchaEnterpriseProvider instance.\r\n     * @param siteKey - reCAPTCHA Enterprise score-based site key.\r\n     */\r\n    constructor(_siteKey) {\r\n        this._siteKey = _siteKey;\r\n        /**\r\n         * Throttle requests on certain error codes to prevent too many retries\r\n         * in a short time.\r\n         */\r\n        this._throttleData = null;\r\n    }\r\n    /**\r\n     * Returns an App Check token.\r\n     * @internal\r\n     */\r\n    async getToken() {\r\n        var _a, _b, _c;\r\n        throwIfThrottled(this._throttleData);\r\n        // Top-level `getToken()` has already checked that App Check is initialized\r\n        // and therefore this._app and this._heartbeatServiceProvider are available.\r\n        const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\r\n            // reCaptcha.execute() throws null which is not very descriptive.\r\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\r\n        });\r\n        // Check if a failure state was set by the recaptcha \"error-callback\".\r\n        if (!((_a = getStateReference(this._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\r\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\r\n        }\r\n        let result;\r\n        try {\r\n            result = await exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);\r\n        }\r\n        catch (e) {\r\n            if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\r\n                this._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), this._throttleData);\r\n                throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\r\n                    time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),\r\n                    httpStatus: this._throttleData.httpStatus\r\n                });\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        // If successful, clear throttle data.\r\n        this._throttleData = null;\r\n        return result;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    initialize(app) {\r\n        this._app = app;\r\n        this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\r\n        initializeEnterprise(app, this._siteKey).catch(() => {\r\n            /* we don't care about the initialization result */\r\n        });\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    isEqual(otherProvider) {\r\n        if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\r\n            return this._siteKey === otherProvider._siteKey;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Custom provider class.\r\n * @public\r\n */\r\nclass CustomProvider {\r\n    constructor(_customProviderOptions) {\r\n        this._customProviderOptions = _customProviderOptions;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    async getToken() {\r\n        // custom provider\r\n        const customToken = await this._customProviderOptions.getToken();\r\n        // Try to extract IAT from custom token, in case this token is not\r\n        // being newly issued. JWT timestamps are in seconds since epoch.\r\n        const issuedAtTimeSeconds = issuedAtTime(customToken.token);\r\n        // Very basic validation, use current timestamp as IAT if JWT\r\n        // has no `iat` field or value is out of bounds.\r\n        const issuedAtTimeMillis = issuedAtTimeSeconds !== null &&\r\n            issuedAtTimeSeconds < Date.now() &&\r\n            issuedAtTimeSeconds > 0\r\n            ? issuedAtTimeSeconds * 1000\r\n            : Date.now();\r\n        return Object.assign(Object.assign({}, customToken), { issuedAtTimeMillis });\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    initialize(app) {\r\n        this._app = app;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    isEqual(otherProvider) {\r\n        if (otherProvider instanceof CustomProvider) {\r\n            return (this._customProviderOptions.getToken.toString() ===\r\n                otherProvider._customProviderOptions.getToken.toString());\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Set throttle data to block requests until after a certain time\r\n * depending on the failed request's status code.\r\n * @param httpStatus - Status code of failed request.\r\n * @param throttleData - `ThrottleData` object containing previous throttle\r\n * data state.\r\n * @returns Data about current throttle state and expiration time.\r\n */\r\nfunction setBackoff(httpStatus, throttleData) {\r\n    /**\r\n     * Block retries for 1 day for the following error codes:\r\n     *\r\n     * 404: Likely malformed URL.\r\n     *\r\n     * 403:\r\n     * - Attestation failed\r\n     * - Wrong API key\r\n     * - Project deleted\r\n     */\r\n    if (httpStatus === 404 || httpStatus === 403) {\r\n        return {\r\n            backoffCount: 1,\r\n            allowRequestsAfter: Date.now() + ONE_DAY,\r\n            httpStatus\r\n        };\r\n    }\r\n    else {\r\n        /**\r\n         * For all other error codes, the time when it is ok to retry again\r\n         * is based on exponential backoff.\r\n         */\r\n        const backoffCount = throttleData ? throttleData.backoffCount : 0;\r\n        const backoffMillis = calculateBackoffMillis(backoffCount, 1000, 2);\r\n        return {\r\n            backoffCount: backoffCount + 1,\r\n            allowRequestsAfter: Date.now() + backoffMillis,\r\n            httpStatus\r\n        };\r\n    }\r\n}\r\nfunction throwIfThrottled(throttleData) {\r\n    if (throttleData) {\r\n        if (Date.now() - throttleData.allowRequestsAfter <= 0) {\r\n            // If before, throw.\r\n            throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\r\n                time: getDurationString(throttleData.allowRequestsAfter - Date.now()),\r\n                httpStatus: throttleData.httpStatus\r\n            });\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Activate App Check for the given app. Can be called only once per app.\r\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\r\n * @param options - App Check initialization options\r\n * @public\r\n */\r\nfunction initializeAppCheck(app = getApp(), options) {\r\n    app = getModularInstance(app);\r\n    const provider = _getProvider(app, 'app-check');\r\n    // Ensure initializeDebugMode() is only called once.\r\n    if (!getDebugState().initialized) {\r\n        initializeDebugMode();\r\n    }\r\n    // Log a message containing the debug token when `initializeAppCheck()`\r\n    // is called in debug mode.\r\n    if (isDebugMode()) {\r\n        // Do not block initialization to get the token for the message.\r\n        void getDebugToken().then(token => \r\n        // Not using logger because I don't think we ever want this accidentally hidden.\r\n        console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));\r\n    }\r\n    if (provider.isInitialized()) {\r\n        const existingInstance = provider.getImmediate();\r\n        const initialOptions = provider.getOptions();\r\n        if (initialOptions.isTokenAutoRefreshEnabled ===\r\n            options.isTokenAutoRefreshEnabled &&\r\n            initialOptions.provider.isEqual(options.provider)) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */, {\r\n                appName: app.name\r\n            });\r\n        }\r\n    }\r\n    const appCheck = provider.initialize({ options });\r\n    _activate(app, options.provider, options.isTokenAutoRefreshEnabled);\r\n    // If isTokenAutoRefreshEnabled is false, do not send any requests to the\r\n    // exchange endpoint without an explicit call from the user either directly\r\n    // or through another Firebase library (storage, functions, etc.)\r\n    if (getStateReference(app).isTokenAutoRefreshEnabled) {\r\n        // Adding a listener will start the refresher and fetch a token if needed.\r\n        // This gets a token ready and prevents a delay when an internal library\r\n        // requests the token.\r\n        // Listener function does not need to do anything, its base functionality\r\n        // of calling getToken() already fetches token and writes it to memory/storage.\r\n        addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, () => { });\r\n    }\r\n    return appCheck;\r\n}\r\n/**\r\n * Activate App Check\r\n * @param app - Firebase app to activate App Check for.\r\n * @param provider - reCAPTCHA v3 provider or\r\n * custom token provider.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. If undefined, defaults to the\r\n * value of `app.automaticDataCollectionEnabled`, which defaults to\r\n * false and can be set in the app config.\r\n */\r\nfunction _activate(app, provider, isTokenAutoRefreshEnabled) {\r\n    // Create an entry in the APP_CHECK_STATES map. Further changes should\r\n    // directly mutate this object.\r\n    const state = setInitialState(app, Object.assign({}, DEFAULT_STATE));\r\n    state.activated = true;\r\n    state.provider = provider; // Read cached token from storage if it exists and store it in memory.\r\n    state.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\r\n        if (cachedToken && isValid(cachedToken)) {\r\n            state.token = cachedToken;\r\n            // notify all listeners with the cached token\r\n            notifyTokenListeners(app, { token: cachedToken.token });\r\n        }\r\n        return cachedToken;\r\n    });\r\n    // Use value of global `automaticDataCollectionEnabled` (which\r\n    // itself defaults to false if not specified in config) if\r\n    // `isTokenAutoRefreshEnabled` param was not provided by user.\r\n    state.isTokenAutoRefreshEnabled =\r\n        isTokenAutoRefreshEnabled === undefined\r\n            ? app.automaticDataCollectionEnabled\r\n            : isTokenAutoRefreshEnabled;\r\n    state.provider.initialize(app);\r\n}\r\n/**\r\n * Set whether App Check will automatically refresh tokens as needed.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. This overrides any value set\r\n * during `initializeAppCheck()`.\r\n * @public\r\n */\r\nfunction setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {\r\n    const app = appCheckInstance.app;\r\n    const state = getStateReference(app);\r\n    // This will exist if any product libraries have called\r\n    // `addTokenListener()`\r\n    if (state.tokenRefresher) {\r\n        if (isTokenAutoRefreshEnabled === true) {\r\n            state.tokenRefresher.start();\r\n        }\r\n        else {\r\n            state.tokenRefresher.stop();\r\n        }\r\n    }\r\n    state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled;\r\n}\r\n/**\r\n * Get the current App Check token. Attaches to the most recent\r\n * in-flight request if one is present. Returns null if no token\r\n * is present and no token requests are in-flight.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param forceRefresh - If true, will always try to fetch a fresh token.\r\n * If false, will use a cached token if found in storage.\r\n * @public\r\n */\r\nasync function getToken(appCheckInstance, forceRefresh) {\r\n    const result = await getToken$2(appCheckInstance, forceRefresh);\r\n    if (result.error) {\r\n        throw result.error;\r\n    }\r\n    return { token: result.token };\r\n}\r\n/**\r\n * Requests a Firebase App Check token. This method should be used\r\n * only if you need to authorize requests to a non-Firebase backend.\r\n *\r\n * Returns limited-use tokens that are intended for use with your\r\n * non-Firebase backend endpoints that are protected with\r\n * <a href=\"https://firebase.google.com/docs/app-check/custom-resource-backend#replay-protection\">\r\n * Replay Protection</a>. This method\r\n * does not affect the token generation behavior of the\r\n * #getAppCheckToken() method.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @returns The limited use token.\r\n * @public\r\n */\r\nfunction getLimitedUseToken(appCheckInstance) {\r\n    return getLimitedUseToken$1(appCheckInstance);\r\n}\r\n/**\r\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\r\n * pattern for public use.\r\n */\r\nfunction onTokenChanged(appCheckInstance, onNextOrObserver, onError, \r\n/**\r\n * NOTE: Although an `onCompletion` callback can be provided, it will\r\n * never be called because the token stream is never-ending.\r\n * It is added only for API consistency with the observer pattern, which\r\n * we follow in JS APIs.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nonCompletion) {\r\n    let nextFn = () => { };\r\n    let errorFn = () => { };\r\n    if (onNextOrObserver.next != null) {\r\n        nextFn = onNextOrObserver.next.bind(onNextOrObserver);\r\n    }\r\n    else {\r\n        nextFn = onNextOrObserver;\r\n    }\r\n    if (onNextOrObserver.error != null) {\r\n        errorFn = onNextOrObserver.error.bind(onNextOrObserver);\r\n    }\r\n    else if (onError) {\r\n        errorFn = onError;\r\n    }\r\n    addTokenListener(appCheckInstance, \"EXTERNAL\" /* ListenerType.EXTERNAL */, nextFn, errorFn);\r\n    return () => removeTokenListener(appCheckInstance.app, nextFn);\r\n}\n\n/**\r\n * Firebase App Check\r\n *\r\n * @packageDocumentation\r\n */\r\nconst APP_CHECK_NAME = 'app-check';\r\nconst APP_CHECK_NAME_INTERNAL = 'app-check-internal';\r\nfunction registerAppCheck() {\r\n    // The public interface\r\n    _registerComponent(new Component(APP_CHECK_NAME, container => {\r\n        // getImmediate for FirebaseApp will always succeed\r\n        const app = container.getProvider('app').getImmediate();\r\n        const heartbeatServiceProvider = container.getProvider('heartbeat');\r\n        return factory(app, heartbeatServiceProvider);\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */)\r\n        .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\r\n        /**\r\n         * Initialize app-check-internal after app-check is initialized to make AppCheck available to\r\n         * other Firebase SDKs\r\n         */\r\n        .setInstanceCreatedCallback((container, _identifier, _appcheckService) => {\r\n        container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\r\n    }));\r\n    // The internal interface used by other Firebase products\r\n    _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, container => {\r\n        const appCheck = container.getProvider('app-check').getImmediate();\r\n        return internalFactory(appCheck);\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\r\n    registerVersion(name, version);\r\n}\r\nregisterAppCheck();\n\nexport { CustomProvider, ReCaptchaEnterpriseProvider, ReCaptchaV3Provider, getLimitedUseToken, getToken, initializeAppCheck, onTokenChanged, setTokenAutoRefreshEnabled };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}